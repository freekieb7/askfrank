// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.943
package views

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

import "hp/internal/web/views/component"

type MeetingPageProps struct {
	component.AppLayoutProps
	MeetingID string
}

func MeetingPage(props MeetingPageProps) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Var2 := templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
			templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
			templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
			if !templ_7745c5c3_IsBuffer {
				defer func() {
					templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
					if templ_7745c5c3_Err == nil {
						templ_7745c5c3_Err = templ_7745c5c3_BufErr
					}
				}()
			}
			ctx = templ.InitializeContext(ctx)
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<div class=\"main-content h-screen flex flex-col\"><!-- Permissions overlay --><div id=\"permissionsOverlay\" class=\"fixed inset-0 bg-black bg-opacity-90 z-50 flex items-center justify-center flex-col p-4\"><div class=\"bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-md w-full p-6 text-center\"><h3 class=\"text-xl font-medium text-gray-900 dark:text-white mb-4\">Camera & Microphone Access</h3><p class=\"text-gray-600 dark:text-gray-400 mb-6\">This meeting requires access to your camera and microphone. Please allow access when prompted by your browser.</p><div class=\"mb-6 flex justify-center\"><div class=\"flex items-center space-x-8\"><div class=\"flex flex-col items-center\"><div id=\"cameraPermStatus\" class=\"w-12 h-12 rounded-full bg-gray-200 dark:bg-gray-700 flex items-center justify-center mb-2\"><i class=\"fas fa-video text-gray-500 dark:text-gray-400 text-xl\"></i></div><span class=\"text-sm text-gray-600 dark:text-gray-400\">Camera</span></div><div class=\"flex flex-col items-center\"><div id=\"micPermStatus\" class=\"w-12 h-12 rounded-full bg-gray-200 dark:bg-gray-700 flex items-center justify-center mb-2\"><i class=\"fas fa-microphone text-gray-500 dark:text-gray-400 text-xl\"></i></div><span class=\"text-sm text-gray-600 dark:text-gray-400\">Microphone</span></div></div></div><p id=\"permissionMessage\" class=\"text-gray-600 dark:text-gray-400 mb-6\">Click the button below to request access.</p><button id=\"requestPermissionsBtn\" type=\"button\" class=\"px-4 py-2 bg-ocean text-white rounded-md hover:bg-ocean-700 focus:outline-none focus:ring-2 focus:ring-ocean-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800\">Request Access</button></div></div><div class=\"bg-gray-900 text-white p-3 flex justify-between items-center\"><div class=\"flex items-center\"><h1 class=\"text-xl font-bold\">Meeting: ")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var3 string
			templ_7745c5c3_Var3, templ_7745c5c3_Err = templ.JoinStringErrs(props.MeetingID)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `internal/web/views/meeting.templ`, Line: 46, Col: 61}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var3))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 2, "</h1><span id=\"participantCount\" class=\"ml-3 text-sm bg-gray-700 px-2 py-1 rounded-full\">1 participant</span></div><div class=\"flex items-center space-x-2\"><button id=\"inviteBtn\" class=\"bg-gray-700 hover:bg-gray-600 px-3 py-1 rounded text-sm\"><i class=\"fas fa-user-plus mr-1\"></i> Invite</button> <button id=\"toggleChatBtn\" class=\"bg-gray-700 hover:bg-gray-600 px-3 py-1 rounded text-sm\"><i class=\"fas fa-comment mr-1\"></i> Chat</button></div></div><div class=\"flex-1 flex\"><!-- Main video container --><div id=\"videoContainer\" class=\"flex-1 p-4 bg-black flex flex-wrap content-start gap-4 overflow-auto\"><!-- Local video will be added here --><div id=\"localVideoContainer\" class=\"relative\"><video id=\"localVideo\" autoplay muted playsinline class=\"rounded-lg shadow-lg bg-gray-800 w-64 h-48 object-cover\"></video><div class=\"absolute bottom-2 left-2 bg-black bg-opacity-50 text-white px-2 py-1 text-xs rounded\">You</div></div><!-- Remote videos will be added here dynamically --></div><!-- Chat sidebar (hidden by default) --><div id=\"chatSidebar\" class=\"w-80 bg-gray-800 text-white hidden flex flex-col\"><div class=\"p-3 border-b border-gray-700 flex justify-between items-center\"><h2 class=\"font-bold\">Chat</h2><button id=\"closeChatBtn\" class=\"text-gray-400 hover:text-white\"><i class=\"fas fa-times\"></i></button></div><div id=\"chatMessages\" class=\"flex-1 p-3 overflow-y-auto space-y-3\"><!-- Chat messages will appear here --></div><div class=\"p-3 border-t border-gray-700\"><form id=\"chatForm\" class=\"flex\"><input type=\"text\" id=\"chatInput\" class=\"flex-1 bg-gray-700 border border-gray-600 rounded-l px-3 py-2 text-white\" placeholder=\"Type a message...\"> <button type=\"submit\" class=\"bg-ocean hover:bg-ocean-700 px-3 py-2 rounded-r\"><i class=\"fas fa-paper-plane\"></i></button></form></div></div></div><!-- Controls bar --><div class=\"bg-gray-900 text-white p-4 flex justify-center space-x-4\"><button id=\"toggleMicBtn\" class=\"bg-gray-700 hover:bg-gray-600 w-12 h-12 rounded-full flex items-center justify-center\"><i class=\"fas fa-microphone\"></i></button> <button id=\"toggleVideoBtn\" class=\"bg-gray-700 hover:bg-gray-600 w-12 h-12 rounded-full flex items-center justify-center\"><i class=\"fas fa-video\"></i></button> <button id=\"toggleScreenShareBtn\" class=\"bg-gray-700 hover:bg-gray-600 w-12 h-12 rounded-full flex items-center justify-center\"><i class=\"fas fa-desktop\"></i></button> <button id=\"leaveBtn\" class=\"bg-red-600 hover:bg-red-700 w-12 h-12 rounded-full flex items-center justify-center\"><i class=\"fas fa-phone-slash\"></i></button></div></div><!-- Modal templates --> <div id=\"inviteModal\" class=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden\"><div class=\"bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-md w-full p-6\"><h3 class=\"text-lg font-medium text-gray-900 dark:text-white mb-4\">Invite to Meeting</h3><p class=\"text-gray-600 dark:text-gray-400 mb-2\">Share this link with others to join the meeting:</p><div class=\"flex mb-4\"><input type=\"text\" id=\"meetingLink\" class=\"flex-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-l-md shadow-sm focus:outline-none dark:bg-gray-700 dark:text-white\" readonly> <button id=\"copyLinkBtn\" class=\"px-4 py-2 bg-gray-100 dark:bg-gray-600 text-gray-700 dark:text-gray-200 border border-gray-300 dark:border-gray-600 rounded-r-md hover:bg-gray-200 dark:hover:bg-gray-500 focus:outline-none\"><i class=\"fas fa-copy\"></i></button></div><div class=\"flex justify-end\"><button type=\"button\" class=\"px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 focus:outline-none dark:bg-gray-700 dark:text-white dark:hover:bg-gray-600\" onclick=\"document.getElementById('inviteModal').classList.add('hidden')\">Close</button></div></div></div><script>\n            // Meeting ID and user info\n            const meetingId = \"{meetingID}\";\n            let localStream = null;\n            let screenStream = null;\n            let isAudioMuted = false;\n            let isVideoOff = false;\n            let isScreenSharing = false;\n            \n            // WebRTC variables\n            const peerConnections = {};\n            let signalingConnection = null;\n            \n            // STUN/TURN servers for ICE\n            const iceServers = {\n                iceServers: [\n                    { urls: \"stun:stun.l.google.com:19302\" },\n                    { urls: \"stun:stun1.l.google.com:19302\" },\n                ]\n            };\n            \n            // Get DOM elements\n            const localVideo = document.getElementById('localVideo');\n            const videoContainer = document.getElementById('videoContainer');\n            const chatSidebar = document.getElementById('chatSidebar');\n            const chatMessages = document.getElementById('chatMessages');\n            const chatForm = document.getElementById('chatForm');\n            const chatInput = document.getElementById('chatInput');\n            const participantCount = document.getElementById('participantCount');\n            \n            // Control buttons\n            const toggleMicBtn = document.getElementById('toggleMicBtn');\n            const toggleVideoBtn = document.getElementById('toggleVideoBtn');\n            const toggleScreenShareBtn = document.getElementById('toggleScreenShareBtn');\n            const toggleChatBtn = document.getElementById('toggleChatBtn');\n            const leaveBtn = document.getElementById('leaveBtn');\n            const inviteBtn = document.getElementById('inviteBtn');\n            const closeChatBtn = document.getElementById('closeChatBtn');\n            const copyLinkBtn = document.getElementById('copyLinkBtn');\n            const requestPermissionsBtn = document.getElementById('requestPermissionsBtn');\n            const permissionsOverlay = document.getElementById('permissionsOverlay');\n            const cameraPermStatus = document.getElementById('cameraPermStatus');\n            const micPermStatus = document.getElementById('micPermStatus');\n            const permissionMessage = document.getElementById('permissionMessage');\n            \n            // Permission status\n            let cameraPermGranted = false;\n            let micPermGranted = false;\n            \n            // Check if permissions are already granted\n            async function checkPermissions() {\n                // First check if the browser supports the permissions API\n                if (navigator.permissions && navigator.permissions.query) {\n                    try {\n                        // Check camera permission\n                        const cameraPermission = await navigator.permissions.query({ name: 'camera' });\n                        console.log(`Camera permission status: ${cameraPermission.state}`);\n                        \n                        if (cameraPermission.state === 'granted') {\n                            updateCameraPermissionUI(true);\n                        } else if (cameraPermission.state === 'denied') {\n                            updateCameraPermissionUI(false);\n                        }\n                        \n                        // Some browsers support querying microphone permission\n                        try {\n                            const micPermission = await navigator.permissions.query({ name: 'microphone' });\n                            console.log(`Microphone permission status: ${micPermission.state}`);\n                            \n                            if (micPermission.state === 'granted') {\n                                updateMicPermissionUI(true);\n                            } else if (micPermission.state === 'denied') {\n                                updateMicPermissionUI(false);\n                            }\n                        } catch (e) {\n                            console.log('Microphone permission query not supported, will check during access');\n                        }\n                        \n                        // Add permission change listeners\n                        cameraPermission.addEventListener('change', (e) => {\n                            console.log(`Camera permission changed to: ${e.target.state}`);\n                            updateCameraPermissionUI(e.target.state === 'granted');\n                        });\n                        \n                        // If permissions are already granted, try to access media\n                        if (cameraPermission.state === 'granted') {\n                            console.log(\"Camera permission already granted, attempting to access media\");\n                            // We'll still wait for the button click to avoid unexpected camera activation\n                        }\n                    } catch (error) {\n                        console.log('Permission query not fully supported, will check when requesting media', error);\n                    }\n                } else {\n                    console.log('Permissions API not supported, will check when requesting media');\n                    // Will have to check by attempting to get the stream\n                }\n            }\n            \n            // Update UI based on camera permission state\n            function updateCameraPermissionUI(granted) {\n                cameraPermGranted = granted;\n                \n                if (granted) {\n                    cameraPermStatus.classList.remove('bg-gray-200', 'dark:bg-gray-700', 'bg-red-100', 'dark:bg-red-900');\n                    cameraPermStatus.classList.add('bg-green-100', 'dark:bg-green-900');\n                    cameraPermStatus.innerHTML = '<i class=\"fas fa-video text-green-600 dark:text-green-400 text-xl\"></i>';\n                } else {\n                    cameraPermStatus.classList.remove('bg-gray-200', 'dark:bg-gray-700', 'bg-green-100', 'dark:bg-green-900');\n                    cameraPermStatus.classList.add('bg-red-100', 'dark:bg-red-900');\n                    cameraPermStatus.innerHTML = '<i class=\"fas fa-video-slash text-red-600 dark:text-red-400 text-xl\"></i>';\n                }\n                \n                updatePermissionMessage();\n            }\n            \n            // Update UI based on mic permission state\n            function updateMicPermissionUI(granted) {\n                micPermGranted = granted;\n                \n                if (granted) {\n                    micPermStatus.classList.remove('bg-gray-200', 'dark:bg-gray-700', 'bg-red-100', 'dark:bg-red-900');\n                    micPermStatus.classList.add('bg-green-100', 'dark:bg-green-900');\n                    micPermStatus.innerHTML = '<i class=\"fas fa-microphone text-green-600 dark:text-green-400 text-xl\"></i>';\n                } else {\n                    micPermStatus.classList.remove('bg-gray-200', 'dark:bg-gray-700', 'bg-green-100', 'dark:bg-green-900');\n                    micPermStatus.classList.add('bg-red-100', 'dark:bg-red-900');\n                    micPermStatus.innerHTML = '<i class=\"fas fa-microphone-slash text-red-600 dark:text-red-400 text-xl\"></i>';\n                }\n                \n                updatePermissionMessage();\n            }\n            \n            // Update the overall permission message\n            function updatePermissionMessage() {\n                if (cameraPermGranted && micPermGranted) {\n                    permissionMessage.textContent = \"All permissions granted! You'll join the meeting momentarily.\";\n                    requestPermissionsBtn.style.display = 'none';\n                    \n                    // Hide overlay after a short delay\n                    setTimeout(() => {\n                        permissionsOverlay.classList.add('hidden');\n                    }, 1500);\n                } else if (cameraPermGranted || micPermGranted) {\n                    permissionMessage.textContent = \"Additional permissions required. Please click the button below.\";\n                    requestPermissionsBtn.textContent = \"Grant Missing Permissions\";\n                } else {\n                    permissionMessage.textContent = \"Camera and microphone access is required for meetings.\";\n                    requestPermissionsBtn.textContent = \"Request Access\";\n                }\n            }\n            \n            // Request access to camera and microphone\n            async function requestMediaAccess() {\n                try {\n                    permissionMessage.textContent = \"Requesting permissions...\";\n                    requestPermissionsBtn.disabled = true;\n                    \n                    // More detailed video constraints to handle potential issues\n                    const constraints = {\n                        audio: true,\n                        video: {\n                            width: { ideal: 1280, min: 640 },\n                            height: { ideal: 720, min: 480 },\n                            facingMode: \"user\"\n                        }\n                    };\n                    \n                    try {\n                        // First try with both audio and video\n                        localStream = await navigator.mediaDevices.getUserMedia(constraints);\n                        \n                        // Update permission status\n                        updateCameraPermissionUI(true);\n                        updateMicPermissionUI(true);\n                    } catch (mediaError) {\n                        console.error(\"Error with full media request:\", mediaError);\n                        \n                        // If that fails, try with just audio and handle camera separately\n                        if (mediaError.name === \"NotFoundError\" || \n                            mediaError.name === \"DevicesNotFoundError\" || \n                            mediaError.message.includes(\"could not be found\")) {\n                            \n                            console.log(\"Camera not found, falling back to audio only\");\n                            \n                            // Try audio only\n                            localStream = await navigator.mediaDevices.getUserMedia({ audio: true });\n                            updateMicPermissionUI(true);\n                            updateCameraPermissionUI(false);\n                            \n                            // Show camera error message\n                            permissionMessage.innerHTML = \"Your microphone is working, but we couldn't access your camera.<br><small>Please check that your camera is connected and not in use by another application.</small>\";\n                            permissionMessage.classList.add('text-yellow-600', 'dark:text-yellow-400');\n                            \n                            // Keep the permissions overlay visible but change the button text\n                            requestPermissionsBtn.disabled = false;\n                            requestPermissionsBtn.textContent = \"Continue with Audio Only\";\n                            requestPermissionsBtn.addEventListener('click', function continueAudioOnly() {\n                                // Remove this specific event listener\n                                requestPermissionsBtn.removeEventListener('click', continueAudioOnly);\n                                // Hide the overlay\n                                permissionsOverlay.classList.add('hidden');\n                            }, { once: true });\n                            \n                            // Don't continue with the rest of the function\n                            return;\n                        } else {\n                            // Re-throw for other errors to be caught by the outer catch\n                            throw mediaError;\n                        }\n                    }\n                    \n                    // Display local video\n                    localVideo.srcObject = localStream;\n                    \n                    // Connect to signaling server\n                    connectSignaling();\n                    \n                    // Set meeting link for invitation\n                    document.getElementById('meetingLink').value = window.location.href;\n                    \n                    requestPermissionsBtn.disabled = false;\n                    \n                } catch (error) {\n                    console.error(\"Error requesting media access:\", error);\n                    requestPermissionsBtn.disabled = false;\n                    \n                    // Check which permission was denied\n                    if (error.name === \"NotAllowedError\" || error.name === \"PermissionDeniedError\") {\n                        permissionMessage.innerHTML = \"Permission denied. Please allow camera and microphone access in your browser settings and try again.<br><small>You may need to click the camera icon in your browser's address bar.</small>\";\n                        permissionMessage.classList.add('text-red-600', 'dark:text-red-400');\n                    } else if (error.name === \"NotFoundError\" || error.name === \"DevicesNotFoundError\" || error.message.includes(\"could not be found\")) {\n                        permissionMessage.innerHTML = \"Camera or microphone device not found.<br><small>Please check that your devices are properly connected and not being used by another application.</small>\";\n                        permissionMessage.classList.add('text-red-600', 'dark:text-red-400');\n                    } else if (error.name === \"NotReadableError\" || error.name === \"TrackStartError\") {\n                        permissionMessage.innerHTML = \"Could not access your camera or microphone.<br><small>The device might be in use by another application or there might be a hardware error.</small>\";\n                        permissionMessage.classList.add('text-red-600', 'dark:text-red-400');\n                    } else if (error.name === \"OverconstrainedError\") {\n                        permissionMessage.innerHTML = \"Your camera doesn't meet the required constraints.<br><small>Try using a different camera if available.</small>\";\n                        permissionMessage.classList.add('text-red-600', 'dark:text-red-400');\n                    } else if (error.name === \"TypeError\" && error.message.includes(\"undefined\")) {\n                        permissionMessage.innerHTML = \"Browser API error. Please refresh the page and try again.\";\n                        permissionMessage.classList.add('text-red-600', 'dark:text-red-400');\n                    } else {\n                        permissionMessage.innerHTML = `Error accessing media devices: ${error.message}<br><small>(${error.name})</small>`;\n                        permissionMessage.classList.add('text-red-600', 'dark:text-red-400');\n                    }\n                    \n                    // Try to determine which specific permission failed\n                    try {\n                        const audioOnly = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });\n                        updateMicPermissionUI(true);\n                        audioOnly.getTracks().forEach(track => track.stop()); // Clean up\n                        \n                        // If microphone works but we still have an error, it's likely a camera issue\n                        if (error.name === \"NotFoundError\" || error.message.includes(\"could not be found\")) {\n                            // Add option to continue with audio only\n                            permissionMessage.innerHTML += \"<br><br>You can continue with audio only if your camera is unavailable.\";\n                            requestPermissionsBtn.textContent = \"Continue with Audio Only\";\n                            requestPermissionsBtn.addEventListener('click', function audioOnlyHandler() {\n                                // Create audio-only stream\n                                navigator.mediaDevices.getUserMedia({ audio: true, video: false })\n                                    .then(stream => {\n                                        localStream = stream;\n                                        updateMicPermissionUI(true);\n                                        connectSignaling();\n                                        permissionsOverlay.classList.add('hidden');\n                                    })\n                                    .catch(err => {\n                                        console.error(\"Failed to get audio stream:\", err);\n                                    });\n                                \n                                // Remove this specific handler\n                                requestPermissionsBtn.removeEventListener('click', audioOnlyHandler);\n                            }, { once: true });\n                        }\n                    } catch (e) {\n                        updateMicPermissionUI(false);\n                    }\n                    \n                    try {\n                        const videoOnly = await navigator.mediaDevices.getUserMedia({ \n                            audio: false, \n                            video: {\n                                width: { ideal: 640, min: 320 },\n                                height: { ideal: 480, min: 240 }\n                            } \n                        });\n                        updateCameraPermissionUI(true);\n                        videoOnly.getTracks().forEach(track => track.stop()); // Clean up\n                    } catch (e) {\n                        console.error(\"Video only test failed:\", e);\n                        updateCameraPermissionUI(false);\n                    }\n                }\n            }\n            \n            // Initialize the meeting\n            async function initializeMeeting() {\n                // Check available devices first (for diagnostics)\n                try {\n                    const devices = await navigator.mediaDevices.enumerateDevices();\n                    const videoDevices = devices.filter(device => device.kind === 'videoinput');\n                    const audioDevices = devices.filter(device => device.kind === 'audioinput');\n                    \n                    console.log(`Available devices: ${devices.length} total`);\n                    console.log(`Video input devices: ${videoDevices.length}`);\n                    console.log(`Audio input devices: ${audioDevices.length}`);\n                    \n                    if (videoDevices.length === 0) {\n                        console.warn(\"No video input devices detected!\");\n                        updateCameraPermissionUI(false);\n                        permissionMessage.innerHTML = \"No camera detected on your device.<br><small>You can still join with audio only.</small>\";\n                    }\n                    \n                    if (audioDevices.length === 0) {\n                        console.warn(\"No audio input devices detected!\");\n                        updateMicPermissionUI(false);\n                        permissionMessage.innerHTML = \"No microphone detected on your device.<br><small>You may not be able to speak in the meeting.</small>\";\n                    }\n                } catch (err) {\n                    console.error(\"Error enumerating devices:\", err);\n                }\n                \n                // Check for existing permissions\n                await checkPermissions();\n                \n                // Add event listener for permission button\n                requestPermissionsBtn.addEventListener('click', requestMediaAccess);\n            }\n            \n            // Connect to the signaling server\n            function connectSignaling() {\n                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n                const wsUrl = `${protocol}//${window.location.host}/ws/rtc`;\n                \n                signalingConnection = new WebSocket(wsUrl);\n                \n                signalingConnection.onopen = () => {\n                    console.log(\"Connected to signaling server\");\n                    // Join the room\n                    sendSignal({\n                        type: \"join\",\n                        roomId: meetingId\n                    });\n                };\n                \n                signalingConnection.onmessage = (event) => {\n                    const signal = JSON.parse(event.data);\n                    handleSignalingMessage(signal);\n                };\n                \n                signalingConnection.onclose = () => {\n                    console.log(\"Disconnected from signaling server\");\n                };\n                \n                signalingConnection.onerror = (error) => {\n                    console.error(\"Signaling server error:\", error);\n                };\n            }\n            \n            // Send signal through the signaling server\n            function sendSignal(signal) {\n                if (signalingConnection && signalingConnection.readyState === WebSocket.OPEN) {\n                    signalingConnection.send(JSON.stringify(signal));\n                }\n            }\n            \n            // Handle incoming signaling messages\n            function handleSignalingMessage(signal) {\n                switch(signal.type) {\n                    case \"room-info\":\n                        const participants = JSON.parse(signal.payload);\n                        updateParticipantCount(participants.length + 1); // +1 for local user\n                        \n                        // Set up connections with existing participants\n                        participants.forEach(participantId => {\n                            createPeerConnection(participantId);\n                            sendOffer(participantId);\n                        });\n                        break;\n                        \n                    case \"user-joined\":\n                        // A new user joined, update UI\n                        const remoteId = signal.from;\n                        console.log(\"User joined:\", remoteId);\n                        // Wait for them to send us an offer\n                        break;\n                        \n                    case \"user-left\":\n                        // A user left, clean up their connection\n                        const leftUserId = signal.from;\n                        closePeerConnection(leftUserId);\n                        break;\n                        \n                    case \"offer\":\n                        handleOffer(signal);\n                        break;\n                        \n                    case \"answer\":\n                        handleAnswer(signal);\n                        break;\n                        \n                    case \"ice-candidate\":\n                        handleIceCandidate(signal);\n                        break;\n                }\n            }\n            \n            // Create a new peer connection for a remote user\n            function createPeerConnection(remoteUserId) {\n                if (peerConnections[remoteUserId]) {\n                    console.log(\"Peer connection already exists for:\", remoteUserId);\n                    return peerConnections[remoteUserId];\n                }\n                \n                const peerConnection = new RTCPeerConnection(iceServers);\n                peerConnections[remoteUserId] = peerConnection;\n                \n                // Add local tracks to the connection\n                localStream.getTracks().forEach(track => {\n                    peerConnection.addTrack(track, localStream);\n                });\n                \n                // Handle ICE candidates\n                peerConnection.onicecandidate = (event) => {\n                    if (event.candidate) {\n                        sendSignal({\n                            type: \"ice-candidate\",\n                            to: remoteUserId,\n                            roomId: meetingId,\n                            payload: JSON.stringify(event.candidate)\n                        });\n                    }\n                };\n                \n                // Handle connection state changes\n                peerConnection.onconnectionstatechange = (event) => {\n                    console.log(`Connection state for ${remoteUserId}:`, peerConnection.connectionState);\n                };\n                \n                // Handle tracks arriving from the remote user\n                peerConnection.ontrack = (event) => {\n                    // Create video element for remote stream if it doesn't exist\n                    let remoteVideo = document.getElementById(`remote-${remoteUserId}`);\n                    \n                    if (!remoteVideo) {\n                        const container = document.createElement('div');\n                        container.id = `container-${remoteUserId}`;\n                        container.className = 'relative';\n                        \n                        remoteVideo = document.createElement('video');\n                        remoteVideo.id = `remote-${remoteUserId}`;\n                        remoteVideo.autoplay = true;\n                        remoteVideo.playsInline = true;\n                        remoteVideo.className = 'rounded-lg shadow-lg bg-gray-800 w-64 h-48 object-cover';\n                        \n                        const label = document.createElement('div');\n                        label.className = 'absolute bottom-2 left-2 bg-black bg-opacity-50 text-white px-2 py-1 text-xs rounded';\n                        label.textContent = `User ${remoteUserId.substring(0, 8)}`;\n                        \n                        container.appendChild(remoteVideo);\n                        container.appendChild(label);\n                        videoContainer.appendChild(container);\n                    }\n                    \n                    // Assign the remote stream to the video element\n                    if (remoteVideo.srcObject !== event.streams[0]) {\n                        remoteVideo.srcObject = event.streams[0];\n                    }\n                };\n                \n                return peerConnection;\n            }\n            \n            // Close a peer connection when a user leaves\n            function closePeerConnection(userId) {\n                const peerConnection = peerConnections[userId];\n                if (peerConnection) {\n                    peerConnection.close();\n                    delete peerConnections[userId];\n                    \n                    // Remove the remote video element\n                    const container = document.getElementById(`container-${userId}`);\n                    if (container) {\n                        container.remove();\n                    }\n                    \n                    // Update participant count\n                    updateParticipantCount(Object.keys(peerConnections).length + 1); // +1 for local user\n                }\n            }\n            \n            // Send an offer to a remote user\n            async function sendOffer(remoteUserId) {\n                try {\n                    const peerConnection = createPeerConnection(remoteUserId);\n                    const offer = await peerConnection.createOffer();\n                    await peerConnection.setLocalDescription(offer);\n                    \n                    sendSignal({\n                        type: \"offer\",\n                        to: remoteUserId,\n                        roomId: meetingId,\n                        payload: JSON.stringify(offer)\n                    });\n                } catch (error) {\n                    console.error(\"Error creating offer:\", error);\n                }\n            }\n            \n            // Handle an incoming offer\n            async function handleOffer(signal) {\n                try {\n                    const remoteUserId = signal.from;\n                    const offer = JSON.parse(signal.payload);\n                    \n                    const peerConnection = createPeerConnection(remoteUserId);\n                    await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));\n                    \n                    const answer = await peerConnection.createAnswer();\n                    await peerConnection.setLocalDescription(answer);\n                    \n                    sendSignal({\n                        type: \"answer\",\n                        to: remoteUserId,\n                        roomId: meetingId,\n                        payload: JSON.stringify(answer)\n                    });\n                } catch (error) {\n                    console.error(\"Error handling offer:\", error);\n                }\n            }\n            \n            // Handle an incoming answer\n            async function handleAnswer(signal) {\n                try {\n                    const remoteUserId = signal.from;\n                    const answer = JSON.parse(signal.payload);\n                    \n                    const peerConnection = peerConnections[remoteUserId];\n                    if (peerConnection) {\n                        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));\n                    }\n                } catch (error) {\n                    console.error(\"Error handling answer:\", error);\n                }\n            }\n            \n            // Handle an incoming ICE candidate\n            async function handleIceCandidate(signal) {\n                try {\n                    const remoteUserId = signal.from;\n                    const candidate = JSON.parse(signal.payload);\n                    \n                    const peerConnection = peerConnections[remoteUserId];\n                    if (peerConnection) {\n                        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n                    }\n                } catch (error) {\n                    console.error(\"Error handling ICE candidate:\", error);\n                }\n            }\n            \n            // Toggle microphone\n            function toggleMicrophone() {\n                if (localStream) {\n                    const audioTracks = localStream.getAudioTracks();\n                    if (audioTracks.length > 0) {\n                        isAudioMuted = !isAudioMuted;\n                        audioTracks[0].enabled = !isAudioMuted;\n                        \n                        // Update UI\n                        toggleMicBtn.innerHTML = isAudioMuted \n                            ? '<i class=\"fas fa-microphone-slash\"></i>' \n                            : '<i class=\"fas fa-microphone\"></i>';\n                        toggleMicBtn.classList.toggle('bg-red-600', isAudioMuted);\n                        toggleMicBtn.classList.toggle('bg-gray-700', !isAudioMuted);\n                    }\n                }\n            }\n            \n            // Toggle camera\n            function toggleCamera() {\n                if (localStream) {\n                    const videoTracks = localStream.getVideoTracks();\n                    if (videoTracks.length > 0) {\n                        isVideoOff = !isVideoOff;\n                        videoTracks[0].enabled = !isVideoOff;\n                        \n                        // Update UI\n                        toggleVideoBtn.innerHTML = isVideoOff \n                            ? '<i class=\"fas fa-video-slash\"></i>' \n                            : '<i class=\"fas fa-video\"></i>';\n                        toggleVideoBtn.classList.toggle('bg-red-600', isVideoOff);\n                        toggleVideoBtn.classList.toggle('bg-gray-700', !isVideoOff);\n                    }\n                }\n            }\n            \n            // Toggle screen sharing\n            async function toggleScreenSharing() {\n                try {\n                    if (!isScreenSharing) {\n                        // Start screen sharing\n                        screenStream = await navigator.mediaDevices.getDisplayMedia({\n                            video: true\n                        });\n                        \n                        // Replace video track in all peer connections\n                        const videoTrack = screenStream.getVideoTracks()[0];\n                        \n                        Object.values(peerConnections).forEach(pc => {\n                            const senders = pc.getSenders();\n                            const videoSender = senders.find(sender => \n                                sender.track && sender.track.kind === 'video'\n                            );\n                            \n                            if (videoSender) {\n                                videoSender.replaceTrack(videoTrack);\n                            }\n                        });\n                        \n                        // Replace local video display\n                        localVideo.srcObject = screenStream;\n                        \n                        // Update button style\n                        toggleScreenShareBtn.classList.replace('bg-gray-700', 'bg-green-600');\n                        isScreenSharing = true;\n                        \n                        // Handle when user stops screen sharing through browser UI\n                        videoTrack.onended = () => {\n                            stopScreenSharing();\n                        };\n                    } else {\n                        stopScreenSharing();\n                    }\n                } catch (error) {\n                    console.error(\"Error toggling screen share:\", error);\n                    alert(\"Could not start screen sharing. Please check permissions.\");\n                }\n            }\n            \n            // Stop screen sharing\n            function stopScreenSharing() {\n                if (screenStream) {\n                    screenStream.getTracks().forEach(track => track.stop());\n                    screenStream = null;\n                    \n                    // Replace with camera video track in all peer connections\n                    const videoTrack = localStream.getVideoTracks()[0];\n                    \n                    Object.values(peerConnections).forEach(pc => {\n                        const senders = pc.getSenders();\n                        const videoSender = senders.find(sender => \n                            sender.track && sender.track.kind === 'video'\n                        );\n                        \n                        if (videoSender) {\n                            videoSender.replaceTrack(videoTrack);\n                        }\n                    });\n                    \n                    // Restore local video display\n                    localVideo.srcObject = localStream;\n                    \n                    // Update button style\n                    toggleScreenShareBtn.classList.replace('bg-green-600', 'bg-gray-700');\n                    isScreenSharing = false;\n                }\n            }\n            \n            // Toggle chat sidebar\n            function toggleChat() {\n                chatSidebar.classList.toggle('hidden');\n            }\n            \n            // Show invite modal\n            function showInviteModal() {\n                document.getElementById('inviteModal').classList.remove('hidden');\n            }\n            \n            // Copy meeting link\n            function copyMeetingLink() {\n                const meetingLink = document.getElementById('meetingLink');\n                meetingLink.select();\n                document.execCommand('copy');\n                \n                // Show feedback\n                const originalText = copyLinkBtn.innerHTML;\n                copyLinkBtn.innerHTML = '<i class=\"fas fa-check\"></i>';\n                setTimeout(() => {\n                    copyLinkBtn.innerHTML = originalText;\n                }, 2000);\n            }\n            \n            // Leave meeting\n            function leaveMeeting() {\n                // Close all peer connections\n                Object.keys(peerConnections).forEach(userId => {\n                    closePeerConnection(userId);\n                });\n                \n                // Stop all local media tracks\n                if (localStream) {\n                    localStream.getTracks().forEach(track => track.stop());\n                }\n                \n                if (screenStream) {\n                    screenStream.getTracks().forEach(track => track.stop());\n                }\n                \n                // Notify server\n                sendSignal({\n                    type: \"leave\",\n                    roomId: meetingId\n                });\n                \n                // Close signaling connection\n                if (signalingConnection) {\n                    signalingConnection.close();\n                }\n                \n                // Redirect to home page\n                window.location.href = \"/\";\n            }\n            \n            // Update participant count in UI\n            function updateParticipantCount(count) {\n                participantCount.textContent = `${count} ${count === 1 ? 'participant' : 'participants'}`;\n            }\n            \n            // Event listeners\n            toggleMicBtn.addEventListener('click', toggleMicrophone);\n            toggleVideoBtn.addEventListener('click', toggleCamera);\n            toggleScreenShareBtn.addEventListener('click', toggleScreenSharing);\n            toggleChatBtn.addEventListener('click', toggleChat);\n            closeChatBtn.addEventListener('click', toggleChat);\n            inviteBtn.addEventListener('click', showInviteModal);\n            copyLinkBtn.addEventListener('click', copyMeetingLink);\n            leaveBtn.addEventListener('click', leaveMeeting);\n            \n            // Chat form submission\n            chatForm.addEventListener('submit', (e) => {\n                e.preventDefault();\n                const message = chatInput.value.trim();\n                if (message) {\n                    // TODO: Implement chat functionality\n                    // For now, just show it locally\n                    const messageEl = document.createElement('div');\n                    messageEl.className = 'p-2 bg-ocean-600 rounded text-white self-end max-w-xs';\n                    messageEl.textContent = message;\n                    \n                    const wrapper = document.createElement('div');\n                    wrapper.className = 'flex justify-end';\n                    wrapper.appendChild(messageEl);\n                    \n                    chatMessages.appendChild(wrapper);\n                    chatMessages.scrollTop = chatMessages.scrollHeight;\n                    \n                    chatInput.value = '';\n                }\n            });\n            \n            // Initialize when the page loads\n            document.addEventListener('DOMContentLoaded', initializeMeeting);\n            \n            // Handle page unload\n            window.addEventListener('beforeunload', () => {\n                leaveMeeting();\n            });\n        </script>")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			return nil
		})
		templ_7745c5c3_Err = component.AppLayout(props.AppLayoutProps).Render(templ.WithChildren(ctx, templ_7745c5c3_Var2), templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate
