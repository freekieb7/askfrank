package views

import "hp/internal/web/views/component"

type MeetingPageProps struct {
	component.AppLayoutProps
	MeetingID string
}

templ MeetingPage(props MeetingPageProps) {
	@component.AppLayout(props.AppLayoutProps) {
		<div id="meeting" class="h-screen flex flex-col bg-gray-900 text-white" data-meeting-id={ props.MeetingID }>
			<!-- Header with 					ws.send(JSON.stringify({
						type: 'ice-candidate',
						to: participantId,
						from: userId,
						roomId: meetingId,
						roomID: meetingId,
						payload: JSON.stringify(event.candidate)
					})); info and					ws.send(JSON.stringify({
						type: 'offer',
						to: participantId,
						from: userId,
						roomId: meetingId,
						roomID: meetingId,
						payload: JSON.stringify(offer)
					}));ipants -->
			<div class="bg-gray-800 p-4 flex justify-between items-center border-b border-gray-700">
				<div class="flex items-center">
					<h1 class="text-xl font-bold">Meeting: { props.MeetingID }</h1>
					<span id="connectionStatus" class="ml-3 px-2 py-1 rounded text-sm bg-yellow-600">Connecting...</span>
				</div>
				<div class="flex items-center space-x-4">
					<div class="flex items-center">
						<span class="text-sm text-gray-300 mr-2">Participants:</span>
						<span id="participantCount" class="bg-blue-600 px-2 py-1 rounded text-sm">0</span>
					</div>
					<button id="copyLinkBtn" class="bg-gray-700 hover:bg-gray-600 px-3 py-1 rounded text-sm">
						Share Link
					</button>
				</div>
			</div>
			<!-- Main content area with video grid and participant list -->
			<div class="flex-1 flex">
				<!-- Video grid -->
				<div class="flex-1 p-4">
					<div id="videoGrid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 h-full">
						<!-- Local video -->
						<div class="relative bg-gray-800 rounded-lg overflow-hidden">
							<video id="localVideo" autoplay playsinline muted class="w-full h-full object-cover"></video>
							<div class="absolute bottom-2 left-2 bg-black bg-opacity-50 px-2 py-1 rounded text-sm">
								You (Local)
							</div>
						</div>
						<!-- Remote videos will be added here dynamically -->
					</div>
				</div>
				<!-- Participant sidebar -->
				<div class="w-80 bg-gray-800 border-l border-gray-700 flex flex-col">
					<div class="p-4 border-b border-gray-700">
						<h3 class="font-semibold text-lg">Participants</h3>
					</div>
					<div class="flex-1 overflow-y-auto">
						<div id="participantList" class="p-4 space-y-2">
							<!-- Participant items will be added here -->
						</div>
					</div>
				</div>
			</div>
			<!-- Controls -->
			<div class="bg-gray-800 p-4 flex justify-center space-x-4 border-t border-gray-700">
				<button id="toggleMicBtn" class="bg-gray-700 hover:bg-gray-600 w-12 h-12 rounded-full flex items-center justify-center">
					<i class="fas fa-microphone text-white"></i>
				</button>
				<button id="toggleVideoBtn" class="bg-gray-700 hover:bg-gray-600 w-12 h-12 rounded-full flex items-center justify-center">
					<i class="fas fa-video text-white"></i>
				</button>
				<button id="leaveBtn" class="bg-red-600 hover:bg-red-700 w-12 h-12 rounded-full flex items-center justify-center">
					<i class="fas fa-phone-slash text-white"></i>
				</button>
			</div>
		</div>
		<script>
			const meetingId = document.getElementById('meeting').dataset.meetingId;
			const ws = new WebSocket(`wss://dentately-famous-daleyza.ngrok-free.dev/ws/rtc`);
			
			// Generate a unique user ID for this session
			const userId = 'user_' + Math.random().toString(36).substr(2, 9);
			
			// WebRTC configuration
			const rtcConfig = {
				iceServers: [
					{ urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'] }
				],
				iceCandidatePoolSize: 10,
			};

			// State management
			const peerConnections = new Map(); // Map of userId -> RTCPeerConnection
			const remoteStreams = new Map(); // Map of userId -> MediaStream
			let localStream = null;
			let isAudioMuted = false;
			let isVideoOff = false;
			
			// DOM elements
			const localVideo = document.getElementById('localVideo');
			const videoGrid = document.getElementById('videoGrid');
			const participantList = document.getElementById('participantList');
			const participantCount = document.getElementById('participantCount');
			const connectionStatus = document.getElementById('connectionStatus');
			const toggleMicBtn = document.getElementById('toggleMicBtn');
			const toggleVideoBtn = document.getElementById('toggleVideoBtn');
			const leaveBtn = document.getElementById('leaveBtn');
			const copyLinkBtn = document.getElementById('copyLinkBtn');

			// Initialize media and WebSocket
			async function initialize() {
				try {
					console.log('Initializing media devices...');
					// Get local media
					localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
					localVideo.srcObject = localStream;
					
					console.log('Local media initialized:', localStream.getTracks().map(t => `${t.kind}:${t.enabled}`));
					
				// If WebSocket is already connected, join the room now
				if (ws.readyState === WebSocket.OPEN) {
					console.log('WebSocket ready, joining room now');
					ws.send(JSON.stringify({
						type: 'join',
						roomId: meetingId,
						roomID: meetingId, // Also send with capital ID for server compatibility
						from: userId
					}));
				}					updateConnectionStatus('connected', 'Media Ready');
				} catch (error) {
					console.error('Error accessing media devices:', error);
					updateConnectionStatus('error', 'Media Error');
				}
			}

			// WebSocket event handlers
			ws.onopen = async () => {
				console.log('WebSocket connected');
				updateConnectionStatus('connected', 'Connected');
				
				// Wait for media to be ready before joining
				if (localStream) {
					console.log('Local stream ready, joining room');
					ws.send(JSON.stringify({
						type: 'join',
						roomId: meetingId,
						roomID: meetingId, // Also send with capital ID for server compatibility
						from: userId
					}));
				} else {
					console.log('Waiting for local stream before joining room');
					// Will join after media is initialized
				}
			};

			ws.onmessage = async (event) => {
				const message = JSON.parse(event.data);
				console.log('Received message:', message);

				switch (message.type) {
					case 'room-info':
						handleRoomInfo(message);
						break;
					case 'user-joined':
						handleUserJoined(message);
						break;
					case 'user-left':
						handleUserLeft(message);
						break;
					case 'offer':
						handleOffer(message);
						break;
					case 'answer':
						handleAnswer(message);
						break;
					case 'ice-candidate':
						handleIceCandidate(message);
						break;
				}
			};

			ws.onclose = () => {
				updateConnectionStatus('disconnected', 'Disconnected');
			};

			ws.onerror = (error) => {
				console.error('WebSocket error:', error);
				updateConnectionStatus('error', 'Connection Error');
			};

			// Room management functions
			function handleRoomInfo(message) {
				let existingParticipants = [];
				if (message.payload) {
					try {
						existingParticipants = typeof message.payload === 'string' ? JSON.parse(message.payload) : message.payload;
					} catch (e) {
						console.error('Error parsing room info payload:', e);
						existingParticipants = [];
					}
				}
				console.log('Room info received, existing participants:', existingParticipants);
				
				// Create peer connections for existing participants
				existingParticipants.forEach(participantId => {
					console.log('Creating peer connection for existing participant:', participantId);
					addParticipant(participantId);
					createPeerConnection(participantId, true); // As initiator
				});
				
				updateParticipantCount();
			}

			function handleUserJoined(message) {
				console.log('User joined:', message.from);
				addParticipant(message.from);
				createPeerConnection(message.from, false); // As receiver
				updateParticipantCount();
			}

			function handleUserLeft(message) {
				console.log('User left:', message.from);
				removeParticipant(message.from);
				
				// Clean up peer connection
				if (peerConnections.has(message.from)) {
					peerConnections.get(message.from).close();
					peerConnections.delete(message.from);
				}
				
				updateParticipantCount();
			}

			// Participant UI management
			function addParticipant(participantId) {
				// Add to participant list
				const participantItem = document.createElement('div');
				participantItem.id = `participant-${participantId}`;
				participantItem.className = 'flex items-center space-x-3 p-2 bg-gray-700 rounded';
				participantItem.innerHTML = `
					<div class="w-8 h-8 bg-blue-600 rounded-full flex items-center justify-center text-sm font-semibold">
						${participantId.substr(0, 2).toUpperCase()}
					</div>
					<span class="flex-1 text-sm">${participantId}</span>
					<div class="flex space-x-1">
						<div class="w-2 h-2 bg-green-500 rounded-full" title="Audio on"></div>
						<div class="w-2 h-2 bg-green-500 rounded-full" title="Video on"></div>
					</div>
				`;
				participantList.appendChild(participantItem);

				// Add video element for remote stream
				const videoContainer = document.createElement('div');
				videoContainer.id = `video-${participantId}`;
				videoContainer.className = 'relative bg-gray-800 rounded-lg overflow-hidden';
				videoContainer.innerHTML = `
					<video autoplay playsinline class="w-full h-full object-cover"></video>
					<div class="absolute bottom-2 left-2 bg-black bg-opacity-50 px-2 py-1 rounded text-sm">
						${participantId}
					</div>
				`;
				videoGrid.appendChild(videoContainer);
			}

			function removeParticipant(participantId) {
				// Remove from participant list
				const participantItem = document.getElementById(`participant-${participantId}`);
				if (participantItem) {
					participantItem.remove();
				}

				// Remove video element
				const videoContainer = document.getElementById(`video-${participantId}`);
				if (videoContainer) {
					videoContainer.remove();
				}

				// Clean up remote stream
				if (remoteStreams.has(participantId)) {
					remoteStreams.delete(participantId);
				}
			}

			function updateParticipantCount() {
				const count = participantList.children.length + 1; // +1 for local user
				participantCount.textContent = count;
			}

			function updateConnectionStatus(status, text) {
				connectionStatus.textContent = text;
				connectionStatus.className = connectionStatus.className.replace(/bg-\w+-\d+/, '');
				
				switch (status) {
					case 'connected':
						connectionStatus.classList.add('bg-green-600');
						break;
					case 'connecting':
						connectionStatus.classList.add('bg-yellow-600');
						break;
					case 'disconnected':
						connectionStatus.classList.add('bg-gray-600');
						break;
					case 'error':
						connectionStatus.classList.add('bg-red-600');
						break;
				}
			}

			// WebRTC functions
			async function createPeerConnection(participantId, isInitiator) {
				console.log(`Creating peer connection for ${participantId}, isInitiator: ${isInitiator}`);
				const pc = new RTCPeerConnection(rtcConfig);
				peerConnections.set(participantId, pc);

				// Add connection state monitoring
				pc.onconnectionstatechange = () => {
					console.log(`Peer connection state for ${participantId}:`, pc.connectionState);
				};

				pc.oniceconnectionstatechange = () => {
					console.log(`ICE connection state for ${participantId}:`, pc.iceConnectionState);
				};

				pc.onicegatheringstatechange = () => {
					console.log(`ICE gathering state for ${participantId}:`, pc.iceGatheringState);
				};

				// Add local stream tracks to peer connection
				if (localStream) {
					console.log(`Adding ${localStream.getTracks().length} local tracks to peer connection for ${participantId}`);
					localStream.getTracks().forEach(track => {
						console.log(`Adding track: ${track.kind} (enabled: ${track.enabled})`);
						pc.addTrack(track, localStream);
					});
				} else {
					console.warn('No local stream available when creating peer connection for', participantId);
				}

				// Handle incoming tracks
				pc.ontrack = (event) => {
					console.log('Received remote track from:', participantId, 'Track kind:', event.track.kind);
					const remoteStream = event.streams[0];
					remoteStreams.set(participantId, remoteStream);
					
					console.log('Remote stream tracks:', remoteStream.getTracks().map(t => `${t.kind}:${t.enabled}`));
					
					const videoContainer = document.getElementById(`video-${participantId}`);
					if (videoContainer) {
						const video = videoContainer.querySelector('video');
						video.srcObject = remoteStream;
						console.log('Set remote stream to video element for', participantId);
						
						// Add event listeners to monitor video playback
						video.onloadedmetadata = () => console.log('Video metadata loaded for', participantId);
						video.onplay = () => console.log('Video started playing for', participantId);
						video.onerror = (e) => console.error('Video error for', participantId, e);
					} else {
						console.error('Video container not found for participant:', participantId);
					}
				};

				// Handle ICE candidates
				pc.onicecandidate = (event) => {
					if (event.candidate) {
						ws.send(JSON.stringify({
							type: 'ice-candidate',
							to: participantId,
							from: userId,
							roomId: meetingId,
							payload: JSON.stringify(event.candidate)
						}));
					}
				};

				// If initiator, create and send offer
				if (isInitiator) {
					try {
						const offer = await pc.createOffer();
						await pc.setLocalDescription(offer);
						
						ws.send(JSON.stringify({
							type: 'offer',
							to: participantId,
							from: userId,
							roomId: meetingId,
							payload: JSON.stringify(offer)
						}));
					} catch (error) {
						console.error('Error creating offer:', error);
					}
				}
			}

			async function handleOffer(message) {
				const pc = peerConnections.get(message.from);
				if (!pc) return;

				try {
					const offer = JSON.parse(message.payload);
					await pc.setRemoteDescription(offer);
					
					const answer = await pc.createAnswer();
					await pc.setLocalDescription(answer);
					
					ws.send(JSON.stringify({
						type: 'answer',
						to: message.from,
						from: userId,
						roomId: meetingId,
						roomID: meetingId,
						payload: JSON.stringify(answer)
					}));
				} catch (error) {
					console.error('Error handling offer:', error);
				}
			}

			async function handleAnswer(message) {
				const pc = peerConnections.get(message.from);
				if (!pc) return;

				try {
					const answer = JSON.parse(message.payload);
					await pc.setRemoteDescription(answer);
				} catch (error) {
					console.error('Error handling answer:', error);
				}
			}

			async function handleIceCandidate(message) {
				const pc = peerConnections.get(message.from);
				if (!pc) return;

				try {
					const candidate = JSON.parse(message.payload);
					await pc.addIceCandidate(candidate);
				} catch (error) {
					console.error('Error adding ICE candidate:', error);
				}
			}

			// Control button handlers
			toggleMicBtn.addEventListener('click', () => {
				if (localStream) {
					const audioTrack = localStream.getAudioTracks()[0];
					if (audioTrack) {
						audioTrack.enabled = !audioTrack.enabled;
						isAudioMuted = !audioTrack.enabled;
						
						toggleMicBtn.innerHTML = isAudioMuted ? 
							'<i class="fas fa-microphone-slash text-red-500"></i>' :
							'<i class="fas fa-microphone text-white"></i>';
					}
				}
			});

			toggleVideoBtn.addEventListener('click', () => {
				if (localStream) {
					const videoTrack = localStream.getVideoTracks()[0];
					if (videoTrack) {
						videoTrack.enabled = !videoTrack.enabled;
						isVideoOff = !videoTrack.enabled;
						
						toggleVideoBtn.innerHTML = isVideoOff ? 
							'<i class="fas fa-video-slash text-red-500"></i>' :
							'<i class="fas fa-video text-white"></i>';
					}
				}
			});

			leaveBtn.addEventListener('click', () => {
				// Send leave message
				ws.send(JSON.stringify({
					type: 'leave',
					roomId: meetingId,
					roomID: meetingId,
					from: userId
				}));
				
				// Clean up and redirect
				if (localStream) {
					localStream.getTracks().forEach(track => track.stop());
				}
				
				peerConnections.forEach(pc => pc.close());
				ws.close();
				
				window.location.href = '/';
			});

			copyLinkBtn.addEventListener('click', () => {
				const meetingUrl = window.location.href;
				navigator.clipboard.writeText(meetingUrl).then(() => {
					const originalText = copyLinkBtn.textContent;
					copyLinkBtn.textContent = 'Copied!';
					setTimeout(() => {
						copyLinkBtn.textContent = originalText;
					}, 2000);
				});
			});

			// Initialize the application
			initialize();
		</script>
	}
}
